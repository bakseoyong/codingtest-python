def solution(scores):
    answer = 0

    return answer


if __name__ == '__main__':
    # 문제를 잘 못 이해했다. 다른 사원이 압도적으로 크면 다른 사원들이 전부 인센티브 지급 대상에서 제외될 수 있다.
    # 탐색 방법 바꾸기
    # 하나라도 자신보다 점수가 높은 사람이 있으면 커트되는것.
    # 그러면 반대로 내림차순 정렬해서 가장 높은 사람을 기준으로 커트해야 될 듯
    #
    # 일단 근무태도점수 내림차순해서 비교 십만건
    # 여기서 다시 동료 평가 점수로 정렬해서 내림차순해서 비교하면 십만건
    # => 이십만건으로 인센티브 제외 대상 고르기

    scores = [[2, 2], [1, 4], [3, 2], [3, 2], [2, 1]]
    incentive =
    [3, 2] [3, 2] [2, 1] [2, 2] [1, 4] -> [1, 3]

    print(scores)
    #근무 태도 점수로 내림차순 정렬
    scores.sort(key=lambda x: x[0], reverse=True)
    print(scores) #[[3, 2], [3, 2], [2, 2], [2, 1], [1, 4]]
    #커트
    for score in scores:
        if scores[0][0] > score[0] and scores[0][1] > score[1]:


    #동료 평가 점수로 내림차순 정렬

    #print(sorted_by_associate)

    # 1. 석차순으로 정렬한 다음에 완호의 위에 있는 사람들 중에 자르면 되지 않을까?
    # 2. 최악의 경우 10만번쨰라면 위의 사람들을 전부 비교해야 되는데 그러면 100억번 연산해야 된다.
    #
    # 1. 어떤 알고리즘을 사용한 문제일까? 정렬이 들어가니까 이분탐색에 관한 문제가 아닐까? 이분 탐색의 기준은? => 완호의 점수보다 크거나 같은 직원의 수
    # 점수가 같은 사람들끼리 점수와 카운트의 배열을 만들고 이분탐색으로 들어가는 문제 아닐까?

    solution(scores)
