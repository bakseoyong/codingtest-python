def solution(n, roads, sources, destination):
    answer = []

    리스트로 만들면 안된다. 큐에 집어넣어야 된다.
    distances = [] * n

    길이 50만개 그러면 몇개 만들어야 되지...?


    for road in roads:
        #일단 양방향의 거리를 1로 바꾸기
        distances[road[0]]



    return answer

if __name__ == '__main__':
    n = 3
    roads = [[1, 2], [2, 3]]
    sources = [2, 3]
    destination = 1

    solution(n, roads, sources, destination)

    #가장 먼저 떠오르는건 다익스트라 알고리즘
    n은 3이상

    서로 왕복할 수 있도록 구성되어 있다.

    [a, b]가 있다면 [b, a]는 주어지지 않는다.

    sources의 길이는 500이
    소스가 2, 3 에서 목적기 1로 이동해야 되니까

    결국 a에서 b까지 얼마만큼의 시간안에 갈 수 있는지를 물어보는 문제
    1에서 2로갈때 1
    2에서 3로갈때 1
    그래프 탐색
    50만개 연산은 가능하지 않을까 싶다.

    다익스트라 알고리즘은 노드의 제곱의 시간복잡도를 가지고 이는 시간초과를 가져온다.

    그러면 어케하지

    거리가 1로 고정되어 있는데 다익스트라 알고리즘이 필요없고

    출발지 에서 목적지까지 최대한 적은 지역 이동을 하게 만들기만 하면 된다.

    그러면 2에서 1까지 이동
    3에서 1까지 이동
    3에서 갈 수 있는곳 전부 큐에 집어넣고
    2갈수있고 2에서 갈 수 있는 1 큐에 집어넣고
    들리면 visited는 true로 하고 지금 진행하고 있는 방문 리스트들을 저장해야 되는데 그러면 DFS를 써야된다.

    DFS쓰면 스택 넘어가서 런타임 에러 뜰듯. 노드 개수만큼 집어넣어야 되는데

    #
    순차적으로 집어넣는다면?
    집어넣을때마다 집계하면 되지 않을까?
    [1, 2]이면 1에서 2가는걸 1로 설정하고 2에서 1가는걸 1로 설정하고
    [1, 4]이면 1에서 4가는걸 1로, 4에서 1가는걸 1로
    [2, 4]이면 2에서 탐색하니까 1은 갈 수 있네?그러면 2에서 1이 1이니까 1에서 4를 max(기존값, 지금 갱신하는 값)하고 2에서 4가는거 1로 하고,
    4에서 1 갈 수 있네 1에서 2가는게 근데 이미 1이니까 건너 뛰고 4에서 1가는걸 1로 바꾸고(1로 바꿀때는 max 안해줘도 되지. 직행이 뚤려있으니까)

